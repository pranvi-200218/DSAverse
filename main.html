<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSAverse| Interactive Learning</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600;700&family=Roboto+Mono:wght==400;700&display=swap" rel="stylesheet">
    <style>
         :root {
            --text-color: #f4f4f4;
            --background-color: #6c6c75;
            /* Dark Blue/Purple */
            --card-bg: #2e1b2e;
            --border-color: #cbcbe3;
            --main-font: 'Poppins', sans-serif;
            --highlight-color: #ef8e83;
            /* Red */
            --answer-color: #d7da0b;
            /* Yellow/Gold for Answers */
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--main-font);
            background-color: var(--background-color);
            color: var(--text-color);
        }
        
        header {
            background-color: #2e1b2e;
            padding: 15px 5%;
            box-shadow: 0 4px 6px rgba(55, 19, 154, 0.2);
            position: sticky;
            z-index: 1000;
        }
        
        .header-content {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 1.8em;
            color: var(--secondary-color);
        }
        
        .nav-btn {
            text-decoration: underline;
            color: var(--text-color);
            padding: 8px 15px;
            margin: 0 5px;
            font-weight: 600;
            transition: color 0.3s, border-bottom 0.3s;
            display: inline-block;
            font-size: 0.9em;
        }
        
        .nav-btn:hover {
            color: #ef8e83;
        }
        
        main {
            max-width: 1000px;
            margin: 40px auto;
            padding: 0 20px;
        }
        
        .dsa-chapter {
            background-color: var(--card-bg);
            padding: 40px;
            border-radius: 12.5px;
            box-shadow: 0 0 20px rgba(166, 198, 110, 0.5);
            margin-bottom: 40px;
        }
        
        .dsa-chapter:first-of-type {
            display: block;
        }
        
        .dsa-chapter:target {
            display: block;
        }
        
        #chapter-1:target,
        #chapter-2:target,
        #chapter-3:target,
        #chapter-4:target,
        #chapter-5:target,
        #chapter-7:target {
            display: block;
        }
        
        .chapter-title {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .story-text {
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .analogy-box {
            background-color: #e6e1bf50;
            padding: 15px;
            margin: 30px 0;
            font-style: italic;
            font-weight: 600;
            border-radius: 4px;
        }
        
        .learnings-section h3 {
            margin-top: 25px;
            margin-bottom: 10px;
        }
        
        .learnings-section ul {
            list-style: none;
            margin-left: 0;
            padding-left: 0;
        }
        
        .learnings-section li {
            background-color: #2e2e4a;
            margin-bottom: 8px;
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 5px solid var(--secondary-color);
        }
        
        strong {
            color: #f1c40f;
            /* Highlight color for keywords */
        }
        /* --- Interactivity/Demo (PURE CSS HOVER) --- */
        
        .interactive-demo {
            margin-top: 40px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            background-color: #7276a4;
        }
        /* Visual container */
        
        .demo-message {
            margin: 15px auto;
            color: #f2f7f4;
            font-weight: 600;
        }
        
        .room-container,
        .data-array,
        .sort-array {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            height: 60px;
            /* background-color:#8e44ad ; */
        }
        
        .data-array,
        .sort-array {
            height: 80px;
            align-items: flex-end;
            /* Align bars to bottom */
        }
        
        .array-bar {
            width: 30px;
            background-color: var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: var(--code-font);
            transition: all 0.5s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 0.8em;
            font-weight: 700;
        }
        /* Specific heights and colors for Demos (CSS kept for original functionality) */
        
        .sort-array .h1 {
            height: 20px;
            background-color: #8e44ad;
        }
        
        .sort-array .h2 {
            height: 40px;
            background-color: #f1c40f;
        }
        
        .sort-array .h3 {
            height: 60px;
            background-color: #e74c3c;
        }
        
        .sort-array .h4 {
            height: 80px;
            background-color: #2ecc71;
        }
        
        .search-array .s1 {
            height: 20px;
        }
        
        .search-array .s2 {
            height: 35px;
        }
        
        .search-array .s3 {
            height: 50px;
        }
        
        .search-array .s4 {
            height: 65px;
        }
        
        .search-array .s5 {
            height: 80px;
        }
        
        .room,
        .node {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--code-font);
            transition: transform 0.5s ease-in-out, background-color 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .node {
            background-color: var(--secondary-color);
        }
        
        .pointer-arrow {
            font-size: 2em;
            color: var(--border-color);
            line-height: 40px;
        }
        /* Interactivity Button - Hover acts as trigger */
        
        .interactive-btn {
            background-color: rgb(219, 227, 227);
            /* color: var(--background-color); */
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 700;
            transition: background-color 0.3s, transform 0.1s;
        }
        
        .interactive-btn:active {
            transform: scale(0.98);
        }
        /* --- DEMO HOVER LOGIC (UNTOUCHED) --- */
        
        .access-btn:hover~.room-container .index-3 {
            background-color: var(--highlight-color);
            transform: scale(1.1);
        }
        
        .insert-btn:hover~.room-container .index-2,
        .insert-btn:hover~.room-container .index-3,
        .insert-btn:hover~.room-container .index-4 {
            background-color: var(--highlight-color);
            transform: translateY(10px);
        }
        
        .traverse-btn:hover~.linked-list-container .node,
        .traverse-btn:hover~.linked-list-container .pointer-arrow {
            background-color: var(--highlight-color);
            color: white;
        }
        
        .ll-insert-btn:hover~.linked-list-container .node[data-name="B"] {
            background-color: var(--highlight-color);
            transform: scale(1.1);
        }
        
        .enqueue-btn:hover~.room-container .index-4 {
            background-color: var(--secondary-color);
            transform: scale(1.1);
        }
        
        .dequeue-btn:hover~.room-container .index-0 {
            background-color: var(--highlight-color);
            opacity: 0.5;
        }
        
        .linear-search-btn:hover~.data-array .s1 {
            background-color: #8e44ad;
            transform: scale(1.1);
        }
        
        .linear-search-btn:hover~.data-array .s2 {
            background-color: #8e44ad;
            transform: scale(1.1);
            transition-delay: 0.1s;
        }
        
        .linear-search-btn:hover~.data-array .s3 {
            background-color: #8e44ad;
            transform: scale(1.1);
            transition-delay: 0.2s;
        }
        
        .linear-search-btn:hover~.data-array .s4 {
            background-color: var(--highlight-color);
            transform: scale(1.3);
            transition-delay: 0.3s;
        }
        
        .linear-search-btn:hover~.data-array .s5 {
            background-color: #8e44ad;
            transform: scale(1.1);
            transition-delay: 0.4s;
        }
        
        .binary-search-btn:hover~.data-array .s3 {
            background-color: #f1c40f;
            transform: scale(1.1);
        }
        
        .binary-search-btn:hover~.data-array .s4 {
            background-color: var(--highlight-color);
            transform: scale(1.3);
            transition-delay: 0.5s;
        }
        
        .bubble-sort-btn:hover~.sort-array .h3 {
            background-color: var(--highlight-color);
            transform: translateY(-10px);
        }
        
        .bubble-sort-btn:hover~.sort-array .h2 {
            background-color: var(--highlight-color);
            transform: translateY(10px);
            transition-delay: 0.2s;
        }
        
        .bubble-sort-btn:hover~.sort-array .h4 {
            background-color: #8e44ad;
            transition-delay: 0.4s;
        }
        
        .bubble-sort-btn:hover~.sort-array .h1 {
            background-color: #8e44ad;
            transition-delay: 0.6s;
        }
        
        .insertion-sort-btn:hover~.sort-array .h3 {
            background-color: #007bff;
            transform: translateX(-40px);
            transition-delay: 0.5s;
        }
        
        .insertion-sort-btn:hover~.sort-array .h2 {
            background-color: #f1c40f;
            transform: translateX(40px);
            transition-delay: 0.5s;
        }
        /* --- Quiz Section (SIMPLIFIED Q&A) --- */
        
        .quiz-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px dashed var(--border-color);
        }
        
        .quiz-title {
            color: var(--primary-color);
            margin-bottom: 20px;
        }
        
        .question {
            background-color: #2e2e4a;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            /* Simplified border */
            position: relative;
        }
        /* Removed radio buttons and labels from visibility
        .question input[type="radio"], .question label {
            display: none !important;
        } */
        
        .question p {
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .correct-answer {
            display: block;
            margin-top: 10px;
            padding: 10px;
            border-left: 4px solid var(--answer-color);
            background-color: rgba(241, 196, 15, 0.1);
            color: var(--answer-color);
            font-weight: 700;
        }
        /* --- Interview Corner (PURE CSS CHECKED) --- */
        
        .problem-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .interview-problem {
            background-color: #3f3f6e;
            padding: 20px;
            border-radius: 8px;
            position: relative;
            border-left: 4px solid var(--secondary-color);
        }
        
        .google-tag {
            color: #b8ea7b;
        }
        
        .meta-tag {
            color: #26c0e7;
        }
        
        .amazon-tag {
            color: #FF9900;
        }
        
        .problem-title {
            color: rgb(191, 143, 143);
            margin-bottom: 5px;
        }
        /* Hidden Checkbox for Toggling Solutions */
        
        .solution-checkbox {
            display: none;
        }
        /* Button styled as a label linked to the hidden checkbox */
        
        .solution-toggle-label {
            background-color: rgb(173, 134, 83);
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
            display: inline-block;
            transition: background-color 0.3s;
        }
        
        .solution-details {
            margin-top: 10px;
            padding: 10px;
            background-color: #27273f;
            border-radius: 4px;
            font-size: 0.9em;
            display: none;
            /* Hidden by default */
        }
        /* Show solution when checkbox is checked */
        
        .solution-checkbox:checked~.solution-details {
            display: block;
        }
        /* Change label text when checked */
        
        .solution-checkbox:checked+.solution-toggle-label::after {
            content: "Hide Solution";
        }
        
        .solution-toggle-label::after {
            content: "View Solution";
        }
        /* --- Footer --- */
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid var(--border-color);
            color: var(--border-color);
        }
        
        @media (max-width: 600px) {
            .header-content {
                flex-direction: column;
            }
            #chapter-nav {
                margin-top: 10px;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }
            .nav-btn {
                margin: 5px;
            }
            .data-array,
            .sort-array {
                flex-wrap: wrap;
                height: auto;
            }
            .array-bar {
                margin: 2px 5px;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="header-content">
            <h1>DSAverse üè∞</h1>
            <nav id="chapter-nav">
                <a class="nav-btn" href="#chapter-1">Arrays</a>
                <a class="nav-btn" href="#chapter-2">Linked Lists</a>
                <a class="nav-btn" href="#chapter-3">Queues</a>
                <a class="nav-btn" href="#chapter-4">Searching</a>
                <a class="nav-btn" href="#chapter-5">Sorting</a>
                <a class="nav-btn" href="#chapter-7">Interview Corner</a>
            </nav>
        </div>
    </header>
    <main id="content-area">
        <section id="chapter-1" class="dsa-chapter">
            <h2 class="chapter-title">üß© CHAPTER 1: ARRAYS ‚Äî The Hostel of Fixed Rooms üè†</h2>
            <p class="story-text">
                The Grand Array Hostel stood as a testament to order and precision. Built from the ground up, its blueprint dictated an immutable structure of perfectly uniform rooms, each assigned an address‚Äîits index‚Äîstarting with the venerable 'Room 0'. The rooms
                were not just numbered; they were physically contiguous, bolted side-by-side on a single, uninterrupted stretch of memory land.
                <br> This rigidity granted the Master of the Hostel a unique power: Instantaneous Access. If the Master needed to retrieve the guest from Room 3, there was no search, no delay. By the simple calculation of "Base Address + 3 steps," the
                door opened. This was the Hostel's core strength, a promise of O(1) (Constant Time) retrieval speed that no other structure could boast. You could find any guest, whether in Room 1 or Room 1,000,000, in the blink of an eye.
                <br> However, life within the Array Hostel was defined by its static nature. The capacity was fixed upon construction. Once the 100 rooms were built, there could be no 101st. Expanding the Hostel required demolishing the entire old structure
                and rebuilding a brand-new, larger one, a process both costly and time-consuming.
                <br> The real drama, though, unfolded whenever a new resident needed to be inserted mid-way, perhaps taking up a coveted spot at Room 2. The rule was absolute: all subsequent residents must shift. The guest in Room 2 had to move to 3,
                the one in 3 to 4, and so on, all the way to the end. The poor residents who lived toward the rear were constantly packing their bags and moving down the corridor simply to make space for one newcomer. This mass relocation, required for
                both insertion and deletion, defined the Hostel's major weakness: a grueling O(n) (Linear Time) operation, where the effort grew directly proportional to the size of the Hostel.
                <br> The Array Hostel thus served best as a permanent archive, a structure for a fixed and well-known population, where quick lookups were paramount and structural modifications were rare, a silent, rigid monarch of the memory landscape.
                The residents knew the trade-off: unparalleled speed for access, but a chaotic, slow-motion nightmare for change.
            </p>

            <div class="analogy-box">
                üí° Analogy: An array is like lockers in a corridor ‚Äî fixed count, fixed position.
            </div>

            <div class="learnings-section">
                <h3>üß† In-Depth Learnings (Theory)</h3>
                <ul>
                    <li>Space/Memory: Utilizes Static Memory Allocation. Its size is immutable, determined and fixed upon initialization.</li>
                    <li>Storage: Data elements are guaranteed to be stored contiguously in memory, enabling direct address calculation.</li>
                    <li>Access Time: Retrieval of any element via its index is instantaneous: O(1) (Constant Time), representing its primary performance advantage.</li>
                    <li>Insertion/Deletion Time: These operations are computationally expensive due to the necessity of shifting N elements: O(n) (Linear Time).</li>
                    <li>Use Cases: Optimal for scenarios prioritizing rapid retrieval speed where the collection size is predictable and rarely modified.</li>
                </ul>
            </div>

            <div id="array-interactivity" class="interactive-demo">
                <h4 class="demo-title">üéÆ Interactivity: The Shifting Demo (Hover to see effect)</h4>
                <div class="demo-message">
                    Hover over the buttons below to see the visual cost of the operation!
                </div>
                <button class="interactive-btn access-btn">Access Room 3 (O(1) Demo)</button>
                <button class="interactive-btn insert-btn">Insert at Index 2 (O(n) Demo)</button>

                <div id="hostel-rooms" class="room-container">
                    <div class="room index-0">Room 0</div>
                    <div class="room index-1">Room 1</div>
                    <div class="room index-2">Room 2</div>
                    <div class="room index-3">Room 3</div>
                    <div class="room index-4">Room 4</div>
                </div>
            </div>

            <div class="quiz-section">
                <h4 class="quiz-title">‚ùì Post-Chapter Quiz: Arrays (Self-Test Q&A)</h4>
                <div id="quiz-1-container" class="quiz-container">

                    <div class="question">
                        <p>1. What is the Time Complexity for accessing an element in an Array by its index?</p>
                        <div class="correct-answer">Answer: O(1) (Constant Time)</div>
                    </div>

                    <div class="question">
                        <p>2. What type of memory allocation guarantees that array elements are side-by-side?</p>
                        <div class="correct-answer">Answer: Contiguous storage</div>
                    </div>

                    <div class="question">
                        <p>3. What constraint describes the inability of a standard array to resize itself after creation?</p>
                        <div class="correct-answer">Answer: Static Memory Allocation</div>
                    </div>

                    <div class="question">
                        <p>4. The time complexity for inserting an element at index 0 in a full array is:</p>
                        <div class="correct-answer">Answer: O(n)</div>
                    </div>

                    <div class="question">
                        <p>5. Arrays are typically the superior choice over Linked Lists when the primary need is:</p>
                        <div class="correct-answer">Answer: Fast, random element lookup</div>
                    </div>

                    <div class="question">
                        <p>6. An array stores the data elements in a sequential, index-based manner (True/False).</p>
                        <div class="correct-answer">Answer: True</div>
                    </div>

                </div>
            </div>
        </section>

        <section id="chapter-2" class="dsa-chapter">
            <h2 class="chapter-title">üîó CHAPTER 2: LINKED LISTS ‚Äî The Train with Connectable Cars üöÇ</h2>
            <p class="story-text">
                Meet the Linked List Train, a concept born from the desire for flexibility and freedom. Unlike the Array Hostel's fixed, concrete structure, the Linked List was a collection of independent, movable units known as Nodes. These nodes were scattered across
                the sprawling landscape of memory, wherever a free spot could be found‚Äîthey were non-contiguous.
                <br> What held the train together was not physical proximity, but an unwavering sense of direction. Each Node was like a self-contained train car, carrying its cargo (Data) and, most importantly, a detailed address label‚Äîa Pointer‚Äîthat
                pointed precisely to the location of the next car in the sequence. The whole chain began with a single, designated starting point, the Head, which was the only permanent landmark.
                <br> This design revolutionized the process of expansion and maintenance. If a new passenger car needed to be added after Node B, the conductor simply had to perform two quick actions: change Node B‚Äôs address label to point to the new
                car, and then ensure the new car‚Äôs label pointed to Node C. No mass movement, no one was forced to relocate. The addition or removal of a car, as long as you knew the car before it, was a lightning-fast, O(1) (Constant Time) maneuver.
                The Linked List was the embodiment of Dynamic Memory Allocation, able to fluidly expand and contract its length without restraint.
                <br> However, the flexible structure came with its own challenge: the loss of instant access. If the conductor needed to find the tenth car, they couldn't just jump to it. They had to start at the Head and methodically follow the pointer
                from the first car to the second, the second to the third, and so on, sequentially traversing the entire line until the target was reached. This made finding any specific car a slow, O(n) (Linear Time) operation.
                <br> The Linked List Train was an ideal solution for systems where frequent arrivals and departures occurred at the start or end, such as managing a waiting queue or a history log, valuing structural change speed over random access convenience.
                It was a chain of freedom, where every link was responsible only for knowing its immediate successor.
            </p>

            <div class="analogy-box">
                üí° Analogy: A linked list is like a Scavenger Hunt where each clue points to the next location.
            </div>

            <div class="learnings-section">
                <h3>üß† In-Depth Learnings (Theory)</h3>
                <ul>
                    <li>Space/Memory: Implements Dynamic Memory Allocation. The collection can fluidly expand or contract in size during the program‚Äôs execution.</li>
                    <li>Storage: Nodes are allocated non-contiguously in memory; their logical order is maintained exclusively by internal reference pointers.</li>
                    <li>Access Time: Direct access is impossible; finding the Nth element necessitates sequential traversal from the head, resulting in O(n) (Linear Time) complexity.</li>
                    <li>Insertion/Deletion Time: Modifying the structure (adding or removing a node), once the insertion point is identified, requires only a constant number of pointer manipulations: O(1) (Constant Time).</li>
                    <li>Core Characteristics: The fundamental unit is the Node, containing a data payload and a reference pointer to its successor.</li>
                    <li>Use Cases: Best suited for applications dominated by frequent additions and removals where random access speed is not critical.</li>
                </ul>
            </div>

            <div id="linkedlist-interactivity" class="interactive-demo">
                <h4 class="demo-title">üéÆ Interactivity: The Traversal Demo (Hover to see effect)</h4>
                <div class="demo-message">
                    Hover over the buttons below to see the visual cost of the operation!
                </div>
                <button class="interactive-btn traverse-btn">Find Node C (O(n) Demo)</button>
                <button class="interactive-btn ll-insert-btn">Insert after Node B (O(1) Op)</button>

                <div id="train-cars" class="room-container linked-list-container">
                    <div class="node head-node" data-name="A">Node A</div>
                    <div class="pointer-arrow">-></div>
                    <div class="node" data-name="B">Node B</div>
                    <div class="pointer-arrow">-></div>
                    <div class="node" data-name="C">Node C</div>
                    <div class="pointer-arrow">-></div>
                    <div class="node tail-node" data-name="D">Node D</div>
                </div>
            </div>

            <div class="quiz-section">
                <h4 class="quiz-title">‚ùì Post-Chapter Quiz: Linked Lists (Self-Test Q&A)</h4>
                <div id="quiz-2-container" class="quiz-container">
                    <div class="question">
                        <p>1. Which operation is typically O(1) in a Linked List (assuming the preceding node is known)?</p>
                        <div class="correct-answer">Answer: Insertion/Deletion</div>
                    </div>

                    <div class="question">
                        <p>2. What describes the memory allocation pattern of a Linked List?</p>
                        <div class="correct-answer">Answer: Non-contiguous and dynamic</div>
                    </div>

                    <div class="question">
                        <p>3. Finding the 50th element requires starting at the Head and following 50 pointers. This makes access complexity:</p>
                        <div class="correct-answer">Answer: O(n)</div>
                    </div>

                    <div class="question">
                        <p>4. What two components are contained within every Node in a standard Singly Linked List?</p>
                        <div class="correct-answer">Answer: Data and Pointer</div>
                    </div>

                    <div class="question">
                        <p>5. If you need to add and remove items frequently at the beginning of a collection, which trait makes Linked Lists advantageous?</p>
                        <div class="correct-answer">Answer: O(1) insertion/deletion cost</div>
                    </div>

                    <div class="question">
                        <p>6. A Doubly Linked List differs from a Singly Linked List by containing a second pointer that points:</p>
                        <div class="correct-answer">Answer: Back to the previous node</div>
                    </div>
                </div>
            </div>
        </section>

        <section id="chapter-3" class="dsa-chapter">
            <h2 class="chapter-title">üöå CHAPTER 3: QUEUES ‚Äî The Line for an Amusement Park Ride üé°</h2>
            <p class="story-text">
                The Queue, a simple yet powerful structure, is best understood as the Line for an Amusement Park Ride. The rule here is sacred, unbreakable, and absolute: First-In, First-Out (FIFO). The first person to join the line is the first person to experience
                the thrill of the ride.
                <br> In this meticulous system, the Queue maintains two critical positions: the Front (Head), where the next passenger is ready to exit and board the ride, and the Rear (Tail), where all new patrons must join.
                <br> When a new person arrives, they Enqueue (join) the line at the very back (Rear). Since no one else needs to move or shift, this operation is swift and takes O(1) (Constant Time). It‚Äôs a simple matter of directing the new person to
                the end of the line.
                <br> When a person gets on the ride, they Dequeue (leave) from the very front (Front). Similarly, this is an instant operation. The person at the head of the line simply steps forward, and the next person becomes the new Front. No matter
                how long the line stretches‚Äîwhether ten people or a thousand‚Äîthe actions of joining at the back or leaving from the front remain equally quick.
                <br> This simplicity is the Queue's strength. It's the perfect model for tasks that require strict chronological order and fairness, such as task scheduling in a computer's operating system, handling print jobs, or managing data flow in
                a network. It ensures that no task is unfairly bypassed, regardless of its priority‚Äîthe first one in gets the first chance out. The entire structure is a testament to disciplined, one-directional flow, making it an indispensable tool for
                managing sequential processes across all of computer science.
            </p>

            <div class="analogy-box">
                üí° Analogy: A queue is like a printer spooling tasks‚Äîthe first job sent is the first job printed.
            </div>

            <div class="learnings-section">
                <h3>üß† In-Depth Learnings (Theory)</h3>
                <ul>
                    <li>Core Principle: Operates on a FIFO (First-In, First-Out) basis, ensuring fairness of access.</li>
                    <li>Primary Operations: Enqueue (insert at the Rear/Tail) and Dequeue (remove from the Front/Head).</li>
                    <li>Time Complexity: Both Enqueue and Dequeue typically execute in O(1) (Constant Time), assuming a good implementation (like a Linked List or Circular Array).</li>
                    <li>Structure: Requires tracking pointers to both the Front and the Rear of the collection.</li>
                    <li>Use Cases: Essential for task scheduling, handling shared resources (like printers), breadth-first search (BFS) algorithms, and data buffering.</li>
                </ul>
            </div>

            <div id="queue-interactivity" class="interactive-demo">
                <h4 class="demo-title">üéÆ Interactivity: Enqueue/Dequeue Demo (Hover to see effect)</h4>
                <div class="demo-message">
                    Hover over the buttons below to see the endpoints for insertion and removal!
                </div>
                <button class="interactive-btn enqueue-btn">Enqueue (Add to Rear)</button>
                <button class="interactive-btn dequeue-btn">Dequeue (Remove from Front)</button>

                <div id="queue-line" class="room-container">
                    <div class="room index-0">Front</div>
                    <div class="room index-1">P2</div>
                    <div class="room index-2">P3</div>
                    <div class="room index-3">P4</div>
                    <div class="room index-4">Rear</div>
                </div>
            </div>

            <div class="quiz-section">
                <h4 class="quiz-title">‚ùì Post-Chapter Quiz: Queues (Self-Test Q&A)</h4>
                <div id="quiz-3-container" class="quiz-container">
                    <div class="question">
                        <p>1. What principle governs the order of operations in a Queue?</p>
                        <div class="correct-answer">Answer: FIFO (First-In, First-Out)</div>
                    </div>
                    <div class="question">
                        <p>2. What is the time complexity for both Enqueue and Dequeue operations?</p>
                        <div class="correct-answer">Answer: O(1)</div>
                    </div>
                    <div class="question">
                        <p>3. The term Enqueue refers to adding an element at which end of the Queue?</p>
                        <div class="correct-answer">Answer: Rear</div>
                    </div>
                    <div class="question">
                        <p>4. Which pointer indicates the element that will be removed next?</p>
                        <div class="correct-answer">Answer: Front</div>
                    </div>
                    <div class="question">
                        <p>5. Which common computer science problem frequently uses a Queue structure?</p>
                        <div class="correct-answer">Answer: Task Scheduling/Breadth-First Search (BFS)</div>
                    </div>
                    <div class="question">
                        <p>6. Implementing a Queue using a standard array is inefficient because Dequeue often leads to:</p>
                        <div class="correct-answer">Answer: O(n) element shifting</div>
                    </div>
                </div>
            </div>
        </section>

        <section id="chapter-4" class="dsa-chapter">
            <h2 class="chapter-title">üîç CHAPTER 4: SEARCHING ‚Äî The Library Hunt üìö</h2>
            <p class="story-text">
                Searching is the fundamental quest to locate a single, desired item within a vast collection. Our library analogy perfectly illustrates the difference between efficiency and brute force.
                <br> Imagine you are looking for the ancient scroll of 'The Algorithm.'
                <br> The first method is the Linear Search‚Äîthe approach of a disorganized librarian. The books are scattered randomly across the shelves, utterly unsorted.
                <br> To find the scroll, you must start at the very first shelf and check every single title, shelf by shelf, in sequence, until you either find the scroll or check the last book on the last shelf. In the worst-case scenario, if the scroll
                is the very last item, you will have checked N items, resulting in a cumbersome O(n) (Linear Time) complexity.
                <br> This is simple to implement but terrible for a large library.The second method is the Binary Search‚Äîthe technique of a master strategist. Here, the librarian insists on one prerequisite: all books must be sorted alphabetically by
                title. Now, the search becomes a game of elimination. You walk to the middle of the library and look at the central book. Is 'The Algorithm' before or after this central book? Instantly, you can discard half the library. You then repeat
                the process on the remaining half, checking the new midpoint and discarding another half. This repeated halving means you can find the scroll in a logarithmic number of steps, leading to a stunningly fast O(log n) (Logarithmic Time) complexity.
                <br>A library with a million books could be searched in just 20 steps!The trade-off is clear: Linear Search works on anything but is slow. Binary Search is lightning fast, but only if you invest the initial time and effort to keep the
                collection perfectly sorted. For large, unchanging databases, the initial sort is a small price to pay for the endless, rapid lookups Binary Search provides.
            </p>

            <div class="analogy-box">
                üí° Analogy: **Linear Search** is like looking for a name in an unordered contact list (O(n)). **Binary Search** is like using a phonebook (O(log n)).
            </div>

            <div class="learnings-section">
                <h3>üß† In-Depth Learnings (Theory)</h3>
                <ul>
                    <li>Linear Search Complexity: **O(n)** (Linear Time). Requires checking up to N elements in the worst case. Works on unsorted data.</li>
                    <li>Binary Search Pre-requisite: The data *must* be **sorted** before searching can begin.</li>
                    <li>Binary Search Complexity: **O(log n)** (Logarithmic Time). Cuts the search space in half with every step. Extremely fast on large datasets.</li>
                    <li>Trade-off: Binary search is fast, but the initial step of sorting the data can be expensive (up to O(n log n)).</li>
                    <li>Use Cases: Binary search is standard for large, static, and sorted databases. Linear search is for small or unsorted lists.</li>
                </ul>
            </div>

            <div id="search-interactivity" class="interactive-demo">
                <h4 class="demo-title">üéÆ Interactivity: Search Efficiency Demo (Hover to see comparison)</h4>
                <div class="demo-message">
                    Hover over the buttons below: Red highlights the element check, and Yellow shows the starting/midpoint checks.
                </div>
                <button class="interactive-btn linear-search-btn">Linear Search (O(n) - Target 4)</button>
                <button class="interactive-btn binary-search-btn">Binary Search (O(log n) - Target 4)</button>

                <div id="sorted-array" class="data-array search-array">
                    <div class="array-bar s1">1</div>
                    <div class="array-bar s2">2</div>
                    <div class="array-bar s3">3</div>
                    <div class="array-bar s4">4</div>
                    <div class="array-bar s5">5</div>
                </div>
            </div>

            <div class="quiz-section">
                <h4 class="quiz-title">‚ùì Post-Chapter Quiz: Searching (Self-Test Q&A)</h4>
                <div id="quiz-4-container" class="quiz-container">
                    <div class="question">
                        <p>1. What is the Big O complexity for Linear Search in the worst case?</p>
                        <div class="correct-answer">Answer: O(n)</div>
                    </div>
                    <div class="question">
                        <p>2. What is the fundamental requirement for using a Binary Search algorithm?</p>
                        <div class="correct-answer">Answer: The data must be sorted.</div>
                    </div>
                    <div class="question">
                        <p>3. In Binary Search, the algorithm typically finds the target by repeatedly dividing the search interval in half. What is the complexity?</p>
                        <div class="correct-answer">Answer: O(log n)</div>
                    </div>
                    <div class="question">
                        <p>4. Which search method is best suited for finding an element in a small, unsorted array?</p>
                        <div class="correct-answer">Answer: Linear Search</div>
                    </div>
                    <div class="question">
                        <p>5. Binary Search can be implemented using recursion (True/False).</p>
                        <div class="correct-answer">Answer: True</div>
                    </div>
                    <div class="question">
                        <p>6. If an array has 1024 elements, what is the maximum number of comparisons a Binary Search will need?</p>
                        <div class="correct-answer">Answer: 10</div>
                    </div>
                </div>
            </div>
        </section>

        <section id="chapter-5" class="dsa-chapter">
            <h2 class="chapter-title">üìê CHAPTER 5: SORTING ‚Äî Arranging the Skyscraper Blueprints üèóÔ∏è</h2>
            <p class="story-text">
                Sorting is the art of imposing order on chaos, the act of arranging data elements, like organizing a sprawling set of skyscraper blueprints, into a meaningful sequence. The true complexity lies not in the final ordered stack, but in the journey taken
                to achieve it.
                <br> Consider the architect using Bubble Sort. This slow, methodical technique involves a series of endless, small swaps. The architect compares two adjacent blueprints, and if they‚Äôre in the wrong order, he swaps them. He then moves to
                the next pair and repeats the comparison and swap, iterating across the entire stack until the largest blueprints have "bubbled up" to their correct position.
                <br> Because the process requires multiple passes, and within each pass, nearly all pairs are compared, the total effort quickly escalates to a massive O(n¬≤) (Quadratic Time) complexity. This method is fine for a small cottage's plans
                but would take an eon for a true skyscraper.
                <br> Then there are the advanced methods, like Merge Sort. This architect employs a "Divide and Conquer" strategy. He divides the enormous stack of blueprints into smaller and smaller sub-stacks until each stack contains only one (and
                is thus "sorted"). Then, he meticulously merges these small, sorted stacks back together into a single, perfectly ordered pile. The core magic lies in the merging step, which is highly efficient.
                <br> This process scales beautifully, achieving an average time complexity of O(n log n) (Log-Linear Time). This is the gold standard for handling massive construction projects and large datasets.The choice of sorting algorithm, therefore,
                becomes a critical decision for any project. Simple, slower sorts like Bubble Sort are easy to code and suffice for tiny lists. The more complex, fast algorithms like Merge Sort and Quick Sort are the workhorses of the industry, capable
                of imposing order on millions of data points in a fraction of the time, allowing the digital world's massive structures to stand correctly arranged.
            </p>
            <div class="analogy-box">
                üí° Analogy: **O(n¬≤)** sorting is like manually fixing every misplaced card in a deck (slow). **O(n log n)** is like dividing the deck, sorting each pile, and then merging (fast).
                <div class="learnings-section">
                    <h3>üß† In-Depth Learnings (Theory)</h3>
                    <ul>
                        <li>Quadratic Complexity: Simple sorts like **Bubble**, **Insertion**, and **Selection Sort** have an average time complexity of **O(n¬≤)**. Best for very small arrays.</li>
                        <li>Log-Linear Complexity: Efficient sorts like **Merge Sort** and **Quick Sort** have an average time complexity of **O(n log n)**. Best for large arrays.</li>
                        <li>Space Complexity: Some algorithms (like Merge Sort) require **O(n)** auxiliary space, while others (like Bubble Sort or Quick Sort in-place) require **O(1)** or **O(log n)**.</li>
                        <li>Stability: A sort is *stable* if it preserves the relative order of equal elements. This matters in databases.</li>
                        <li>Adaptive Sorting: **Insertion Sort** is highly efficient when the array is already mostly sorted (it performs close to O(n)).</li>
                    </ul>
                </div>

                <div id="sort-interactivity" class="interactive-demo">
                    <h4 class="demo-title">üéÆ Interactivity: Sorting Comparison Demo (Hover to visualize steps)</h4>
                    <div class="demo-message">
                        Hover over the buttons below to see a single step of the sort's O(n¬≤) inner loop.
                    </div>
                    <button class="interactive-btn bubble-sort-btn">Bubble Sort Step (Compare/Swap)</button>
                    <button class="interactive-btn insertion-sort-btn">Insertion Sort Step (Insertion)</button>

                    <div id="unsorted-array" class="data-array sort-array">
                        <div class="array-bar h3" style="height: 60px;">3</div>
                        <div class="array-bar h2" style="height: 40px;">2</div>
                        <div class="array-bar h4" style="height: 80px;">4</div>
                        <div class="array-bar h1" style="height: 20px;">1</div>
                    </div>
                </div>

                <div class="quiz-section">
                    <h4 class="quiz-title">‚ùì Post-Chapter Quiz: Sorting (Self-Test Q&A)</h4>
                    <div id="quiz-5-container" class="quiz-container">
                        <div class="question">
                            <p>1. Which of the following is considered the slowest basic sorting algorithm in Big O notation?</p>
                            <div class="correct-answer">Answer: Bubble Sort (O(n¬≤))</div>
                        </div>
                        <div class="question">
                            <p>2. What is the average time complexity of Merge Sort, which is often considered ideal for large lists?</p>
                            <div class="correct-answer">Answer: O(n log n)</div>
                        </div>
                        <div class="question">
                            <p>3. The term 'In-place' in sorting algorithms typically refers to:</p>
                            <div class="correct-answer">Answer: Using O(1) auxiliary space (minimal extra memory).</div>
                        </div>
                        <div class="question">
                            <p>4. Which sorting algorithm's best-case time complexity is O(n), when the array is already sorted?</p>
                            <div class="correct-answer">Answer: Insertion Sort</div>
                        </div>
                        <div class="question">
                            <p>5. Which sorting technique is an example of the Divide and Conquer paradigm?</p>
                            <div class="correct-answer">Answer: Merge Sort</div>
                        </div>
                        <div class="question">
                            <p>6. Quick Sort is generally preferred over Merge Sort for sorting arrays because:</p>
                            <div class="correct-answer">Answer: Quick Sort is typically "In-place" (better memory usage).</div>
                        </div>
                    </div>
                </div>
        </section>

        <section id="chapter-7" class="dsa-chapter">
            <h2 class="section-title">üèÜ Interview Corner: Land the Job üíº</h2>
            <p>A curated list of DSA problems frequently asked by top tech companies. Master these patterns!</p>

            <div class="problem-list">
                <div class="interview-problem">
                    <span class="company-tag google-tag">[Google]</span>
                    <h4 class="problem-title">Maximum Subarray Sum (Kadane's)</h4>
                    <p class="problem-desc">Find the contiguous subarray (containing at least one number) which has the largest sum.</p>
                    <input type="checkbox" id="sol-toggle-1" class="solution-checkbox">
                    <label for="sol-toggle-1" class="solution-toggle-label"></label>
                    <div id="sol-1" class="solution-details">The core solution is a Dynamic Programming or Greedy approach known as Kadane's Algorithm. The method involves a single pass (iteration) through the array, dynamically tracking the current maximum sum ending at the current position
                        and simultaneously maintaining the overall global maximum sum found across all subarrays. Time Complexity: O(n).</div>
                </div>

                <div class="interview-problem">
                    <span class="company-tag meta-tag">[Meta]</span>
                    <h4 class="problem-title">Reverse a Linked List</h4>
                    <p class="problem-desc">Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
                    <input type="checkbox" id="sol-toggle-2" class="solution-checkbox">
                    <label for="sol-toggle-2" class="solution-toggle-label"></label>
                    <div id="sol-2" class="solution-details">The standard method involves an iterative approach utilizing three distinct pointers: Current, Previous (initialized to null), and Next (used to temporarily store the link to the subsequent node before the current node's pointer is
                        reversed). This deterministic process guarantees reversal in linear time, O(n).</div>
                </div>

                <div class="interview-problem">
                    <span class="company-tag amazon-tag">[Amazon]</span>
                    <h4 class="problem-title">Two Sum</h4>
                    <p class="problem-desc">Return the indices of the two numbers in an array that add up to a specific target.</p>
                    <input type="checkbox" id="sol-toggle-3" class="solution-checkbox">
                    <label for="sol-toggle-3" class="solution-toggle-label"></label>
                    <div id="sol-3" class="solution-details">The optimal and most efficient solution leverages a Hash Map (or Dictionary) to store each number encountered along with its index during a single pass through the array. This strategy allows for constant time, O(1), lookups for the
                        required complement, ensuring the overall solution maintains a linear time complexity of O(n).</div>
                </div>
            </div>
        </section>
        <section id="footer-placeholder"></section>
    </main>

    <footer>
        <p>Built with üß† and ‚ú®. &copy; 2025 DSA Story-Land.</p>
    </footer>
</body>

</html>